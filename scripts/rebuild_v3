#!/usr/bin/env python3

"""
Builds a fresh data repo from source data
"""
import argparse
import logging
from copy import deepcopy
from os import getcwd
from os.path import dirname, realpath, join, relpath, isfile

from lib.changelog import changelog_prepare
from lib.container import dict_get, dict_get_required, dict_set, unique, find_index_by, first, format_list, \
  dict_remove_many, find_duplicates, dict_cleanup
from lib.date import now_iso, iso_to_iso_safe
from lib.fs import json_read, find_files, json_write, copy, make_zip, file_write
from lib.git import git_get_modified_files, git_dir_is_clean, git_get_dirty_files, git_check_tag, \
  git_get_initial_commit_hash, github_create_release, git_pull, git_commit_all, git_push
from lib.fasta import fasta_read_exactly_one_seq
from lib.minimizer import make_ref_search_index, serialize_ref_search_index

logging.basicConfig(level=logging.INFO)
l = logging.getLogger(__file__)


def get_dataset_capabilities(pathogen_json: dict, dataset_dir: str):
  reference_fasta_path = join(dataset_dir, "reference.fasta")
  if not isfile(reference_fasta_path):
    raise FileNotFoundError(f"Reference sequence must be present, but not found: {reference_fasta_path}")

  other = []
  tree_json_path = join(dataset_dir, "tree.json")
  has_tree_json = isfile(join(dataset_dir, "tree.json"))
  if has_tree_json:
    tree_json = json_read(tree_json_path)
    if dict_get(tree_json, ["extensions", "nextclade", "clade_node_attrs"]) is not None:
      other.append("customClades")

  if dict_get(pathogen_json, ["mutLabels"]) is not None:
    other.append("mutLabels")

  if dict_get(pathogen_json, ["phenotypeData"]) is not None:
    other.append("phenotypeData")

  if dict_get(pathogen_json, ["aaMotifs"]) is not None:
    other.append("aaMotifs")

  qc = []
  for k, q in (dict_get(pathogen_json, ["qc"]) or {}).items():
    if dict_get(q, ["enabled"]):
      qc.append(k)

  return dict_cleanup({
    "qc": qc,
    "primers": True if len(dict_get(pathogen_json, ["primers"]) or []) > 0 else None,
    "other": other
  })


def index_one_dataset(args, pathogen_json_path: str, updated_at: str):
  pathogen_json = json_read(pathogen_json_path)
  dataset_dir = dirname(pathogen_json_path)
  path = relpath(dataset_dir, args.input_dir)

  dict_get_required(pathogen_json, ["attributes", "name", "value"])
  dict_get_required(pathogen_json, ["attributes", "name", "valueFriendly"])
  dict_get_required(pathogen_json, ["attributes", "reference", "value"])
  dict_get_required(pathogen_json, ["attributes", "reference", "valueFriendly"])

  ref = get_ref_seq(pathogen_json, dataset_dir)

  dataset = dict_cleanup({
    "path": path,
    "official": True if dict_get(pathogen_json, ["official"]) == True else False,
    "deprecated": True if dict_get(pathogen_json, ["deprecated"]) == True else False,
    "enabled": False if dict_get(pathogen_json, ["enabled"]) == False else True,
    "experimental": True if dict_get(pathogen_json, ["experimental"]) == True else False,
    "attributes": dict_get_required(pathogen_json, ["attributes"]),
    "files": dict_get_required(pathogen_json, ["files"]),
    "capabilities": get_dataset_capabilities(pathogen_json, dataset_dir),
  })

  return dataset, ref


def get_ref_seq(pathogen_json, dataset_dir):
  files = dict_get_required(pathogen_json, ["files"])
  ref_filename = dict_get_required(files, ["reference"])
  ref_filepath = join(dataset_dir, ref_filename)
  try:
    return fasta_read_exactly_one_seq(ref_filepath)
  except Exception as e:
    raise ValueError(f"When reading reference sequence") from e


def get_new_dataset_order(datasets, dataset_order):
  paths = list(map(lambda d: d["path"], datasets))

  dupes = find_duplicates(dataset_order)
  if len(dupes):
    raise ValueError(
      f"The '.dataset_order' list in 'collection.json' contains duplicated entries: {format_list(dupes)}. "
      f"Please make sure the entries are unique, to avoid ambiguity."
    )

  extra = set(dataset_order).difference(set(paths))

  if len(extra) > 0:
    raise ValueError(
      f"The '.dataset_order' list in 'collection.json' contains entries for datasets that are not found: "
      f"{format_list(extra)}. "
      f"Please double check the existence of datasets and the spelling of their paths in the '.dataset_order' list. "
      f"The full list of datasets that are found:\n  {format_list(paths)}."
    )

  missing = set(paths).difference(set(dataset_order))
  if len(missing):
    l.info(
      f"Adding '.dataset_order' entries to 'collection.json' for the following datasets: {format_list(missing)}. "
      f"Please reorder them manually as needed. This order is used when displaying datasets of the collection in the "
      f"user interface."
    )
    dataset_order += list(missing)
  return dataset_order


def sort_datasets(datasets, dataset_order):
  return [dataset for x in dataset_order for dataset in datasets if dataset["path"] == x]


def parse_args():
  parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

  parser.add_argument('--input-dir', required=True, help='Directory of source files of a dataset collection')
  parser.add_argument('--output-dir', required=True, help='Where to output prepared files')
  parser.add_argument('--temp-dir', default=join(getcwd(), "data_temp"),
                      help='Where to temporarily store release files')

  parser.add_argument('--no-pull', action='store_false',
                      help="Skip pulling latest changes from remote. Note that if "
                           "there are incomatible chanhes this can create hard to resolve merge conflicts.")
  parser.add_argument('--allow-dirty', action='store_true',
                      help="Allow working directory to contain uncommited files. Note that these files will also be "
                           "commited and can potentially be released along with the datasets",
                      )
  parser.add_argument('--commit', action='store_true', help="Commit updates into the repository")
  parser.add_argument('--push', action='store_true', help="Push updates into the remote repository. Implies --commit")
  parser.add_argument('--release', action='store_true', help="Release updates. Implies --commit and --push")
  parser.add_argument('--repo', required=False,
                      help="GitHub repo to push and to release to. You need to have write permission for that."
                      )

  args = parser.parse_args()

  if args.push and not args.repo:
    parser.error("--push requires --repo")
  if args.release and not args.repo:
    parser.error("--release requires --repo")

  if args.release:
    args.push = True

  if args.push:
    args.commit = True

  return args


def main():
  args = parse_args()

  if not args.allow_dirty and not git_dir_is_clean():
    dirty_files = "\n  ".join(git_get_dirty_files())
    raise ValueError(
      f"Uncommited changes detected. Refusing to proceed. Commit or stash changes first, or use --allow-dirty to "
      f"override (not recommended):\n  {dirty_files}"
    )

  if args.no_pull:
    git_pull()

  updated_at = now_iso()
  tag = iso_to_iso_safe(updated_at) if args.release else "unreleased"
  git_check_tag(tag)

  collections = []
  release_infos = []
  all_refs = {}
  for collection_json_path in find_files("collection.json", args.input_dir):
    collection, release_infos, refs = process_one_collection(collection_json_path, args, tag, updated_at)
    collections.append(collection)
    release_infos.extend(release_infos)
    all_refs.update(refs)

  minimizer_index = make_ref_search_index(all_refs)

  minimizer_index_json_path = "minimizer_index.json"
  json_write(
    serialize_ref_search_index(minimizer_index),
    join(args.output_dir, minimizer_index_json_path),
    no_sort_keys=True
  )

  # if len(release_infos) == 0:
  #   l.info("No dataset modifications detected. Will not release anything.")
  #   return

  index_json = {
    "schemaVersion": "3.0.0",
    "updatedAt": updated_at,
    "collections": collections,
    "minimizerIndex": [
      {
        "version": minimizer_index["version"],
        "path": minimizer_index_json_path,
      }
    ]
  }

  index_json_path = join(args.output_dir, "index.json")
  json_write({**index_json, "updatedAt": updated_at}, index_json_path, no_sort_keys=True)

  if args.commit:
    commit_hash = commit_changes(args, tag, release_infos)

    if args.push:
      git_push()

      if args.release:
        release_notes = aggregate_release_notes(release_infos)
        publish_to_github_releases(args, tag, commit_hash, release_notes)


def process_one_collection(collection_json_path, args, tag, updated_at):
  collection_json = json_read(collection_json_path)
  collection_dir = dirname(collection_json_path)

  datasets = []
  refs = {}
  for pathogen_json_path in find_files("pathogen.json", collection_dir):
    try:
      dataset, ref = index_one_dataset(args, pathogen_json_path, updated_at)
      datasets.append(dataset)
      refs.update({dataset["path"]: ref})
    except Exception as e:
      raise ValueError(f"When processing '{pathogen_json_path}'") from e

  dataset_order = get_new_dataset_order(datasets, dict_get_required(collection_json, ["dataset_order"]) or [])
  datasets = sort_datasets(datasets, dataset_order)

  collection_json = {
    **collection_json,
    "dataset_order": dataset_order,
  }
  json_write(collection_json, collection_json_path, no_sort_keys=True)

  release_infos = prepare_dataset_release_infos(args, datasets, collection_dir, tag, updated_at)

  collection_info = deepcopy(collection_json)

  dict_remove_many(collection_info, ["dataset_order"])
  dict_remove_many(collection_info, ["schemaVersion"])

  collection_info = {
    **collection_info,
    "datasets": datasets,
  }

  return collection_info, release_infos, refs


def prepare_dataset_release_infos(args, datasets, collection_dir, tag, updated_at):
  release_infos = []
  for pathogen_json_path in find_files("pathogen.json", collection_dir):
    pathogen_json = json_read(pathogen_json_path)
    dataset_dir = dirname(pathogen_json_path)
    dataset_dir_rel = relpath(dataset_dir, args.input_dir)

    i_dataset = find_index_by(lambda dataset: dataset["path"] == dataset_dir_rel, datasets)
    if i_dataset is None:
      raise ValueError(f"Dataset at '{dataset_dir_rel}' not found in the dataset index. Try to reindex datasets first.")

    dataset = datasets[i_dataset]

    versions = dict_get(dataset, ["versions"]) or []
    versions = list(filter(lambda version: version["tag" == "unreleased"], versions))

    if args.release:
      last_version = first(sorted(versions, reverse=True)) or git_get_initial_commit_hash()
      release_info = prepare_dataset_release_info(dataset_dir, dataset, last_version, updated_at)
      if release_info is None:
        continue

      release_infos.append(release_info)

    version = dict_cleanup({"updatedAt": None if tag == "unreleased" else updated_at, "tag": tag})
    version_with_compat = dict_cleanup({**version, "compatibility": dict_get(pathogen_json, ["compatibility"])})
    versions.insert(0, version_with_compat)
    dict_set(dataset, ["versions"], versions)
    dict_set(dataset, ["version"], version_with_compat)

    dict_set(pathogen_json, ["version"], version)
    json_write(pathogen_json, pathogen_json_path, no_sort_keys=True)

    create_dataset_package(args, dataset, pathogen_json, tag, dataset_dir)

  return release_infos


def aggregate_release_notes(release_infos):
  dataset_names_friendly = format_list(
    unique([get_dataset_name_friendly(release_info["dataset"]) for release_info in release_infos]),
    sep="\n", marker="- ", quote=False
  )
  release_notes = f"This release contains changes for datasets:\n\n{dataset_names_friendly}\n\n\n"
  for release_info in release_infos:
    release_notes += f'\n{release_info["release_notes"]}\n\n'
  return release_notes


def commit_changes(args, tag, release_infos):
  l.info(f"Commiting changes for '{tag}'")

  commit_message = "chore: rebuild"
  if args.release:
    dataset_names = format_list(
      unique([get_dataset_name(release_info["dataset"]) for release_info in release_infos]),
      sep="\n", marker="- ", quote=False
    )
    commit_message = f"chore: release '{tag}'\n\nUpdated datasets:\n\n{dataset_names}"

  return git_commit_all(commit_message)


def publish_to_github_releases(args, tag, commit_hash, release_notes):
  l.info(f"Publishing to GitHub Releases: tag: '{tag}', commit: '{commit_hash}'")
  release_files = list(find_files("*", join(args.temp_dir)))
  github_create_release(
    repo=args.repo,
    version=tag,
    commit_hash=commit_hash,
    release_notes=release_notes,
    files=release_files
  )


def prepare_dataset_release_info(dataset_dir, dataset, last_version, updated_at):
  modified_files = list(git_get_modified_files(from_revision=last_version, dirs=dataset_dir))
  modified_files = list(map(lambda f: realpath(f), modified_files))

  # if len(modified_files) == 0:
  #   return None

  path = dataset["path"]
  l.info(f"Preparing release of '{path}'")

  changelog_path = join(dataset_dir, "CHANGELOG.md")

  # if changelog_path not in modified_files:
  #   raise ValueError(
  #     f"Cannot release dataset '{path}' without changelog. Please add or modify file '{changelog_path}': add '## "
  #     f"Unreleased' section and briefly summarize the changes being released"
  #   )

  release_notes = changelog_prepare(dataset, updated_at, changelog_path)

  return {"dataset": dataset, "release_notes": release_notes, "dataset_dir": dataset_dir}


def create_dataset_package(args, dataset, pathogen_json, tag, dataset_dir):
  path = dataset["path"]
  files = pathogen_json["files"]

  dict_get_required(files, ["reference"])
  dict_get_required(files, ["pathogenJson"])

  out_dir = join(args.output_dir, path, tag)
  for _, file in files.items():
    file = join(dataset_dir, file)
    copy(file, f"{out_dir}/")  # trailing slash is required if destination is a directory

  zip_basename = join(out_dir, "dataset")
  make_zip(dataset_dir, zip_basename)

  path_safe = path.replace("/", "__")
  copy(f"{zip_basename}.zip", join(args.temp_dir, f"{path_safe}__{tag}.zip"))

  not_found_json = {"status": 404, "message": "Not found"}
  json_write(not_found_json, join(args.output_dir, "404.json"))
  file_write("User-agent: *\nDisallow: /\n", join(args.output_dir, "robots.txt"))


def get_dataset_name(dataset):
  return dict_get_required(dataset, ["attributes", "name", "value"])


def get_dataset_name_friendly(dataset):
  return dict_get(dataset, ["attributes", "name", "valueFriendly"]) or get_dataset_name(dataset)


if __name__ == '__main__':
  main()
